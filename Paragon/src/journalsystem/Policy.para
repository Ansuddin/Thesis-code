public class Policy {


	// Paragon definitions
	public static final policy bottom = {Object x:};
	public static final policy top = {:};


	// Integrity
	private static final Object untrustedObserver = new Object();
	private static final Object trustedObserver = new Object();
	private static final Object mostTrustedObserver = new Object();

	private lock endorseLock;

	public static final policy untrusted = { untrustedObserver :; trustedObserver: endorseLock};
	public static final policy trusted = { untrustedObserver :; trustedObserver: };
	public static final policy mostTrusted = { untrustedObserver :; trustedObserver:; mostTrustedObserver };


	public static ?(lowD+trusted) <A>
	A endorse(?(lowD+trusted*untrusted) A x){
		open endorseLock{
			return x;
		}
	}

	//Confidentiality
	private lock declassifyLock;
	
	public static final policy lowD = { Doctor d:; Secretary s:; Object x: declassifyLock };
	
	// Putting locks here since paragon is stupid.
	public static ?(lowD+trusted) lock IsReferred(Doctor); // Proberbly opened in Hospital class.
	// Should be opended when IsReferred is open.
	public static ?(lowD+trusted) lock Referred;
	//Define IsReferred like this:
	// public static ?(lowD+trusted) lock IsReferred(Doctor) {IsReferred(d):Referred}

	public static ?(lowD+trusted) lock IsDoctor(Employee);
	public static ?(lowD+trusted) lock DoctorLock; // The confidentiality policy does not effect anything
	

	public static ?(lowD+trusted) lock OnlyMatrix;	

	public static final policy mediumD = { Doctor d:; Object x: declassifyLock};
	public static final policy highD = { Doctor d: IsReferred(d); Object x : declassifyLock };



	public static ?bottom <A> 
	A declassifyLow(?(bottom*lowD) A x){
		open declassifyLock {
			return x;
		}
	}

	~DoctorLock
	public static ?bottom <A> 
	A declassifyMedium(?(bottom*mediumD) A x){
		open declassifyLock {
			return x;
		}
	}

	~Referred
	public static ?bottom < A> 
	A declassifyHigh(?(bottom*highD) A x){
		open declassifyLock {
			return x;	
		}
	}




}